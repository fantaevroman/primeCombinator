<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, shrink-to-fit=no">
    <link href="assets/images/primeCombinatorLogo.png" rel="icon"/>
    <title>Prime Combinator</title>
    <meta name="description" content="Kotlin parsing combinator">
    <meta name="author" content="Roman Fantaev">

    <!-- Stylesheet
    ============================== -->
    <!-- Bootstrap -->
    <link rel="stylesheet" type="text/css" href="assets/vendor/bootstrap/css/bootstrap.min.css"/>
    <!-- Font Awesome Icon -->
    <link rel="stylesheet" type="text/css" href="assets/vendor/font-awesome/css/all.min.css"/>
    <!-- Magnific Popup -->
    <link rel="stylesheet" type="text/css" href="assets/vendor/magnific-popup/magnific-popup.min.css"/>
    <!-- Highlight Syntax -->
    <link rel="stylesheet" type="text/css" href="assets/vendor/highlight.js/styles/github.css"/>
    <!-- Custom Stylesheet -->
    <link rel="stylesheet" type="text/css" href="assets/css/stylesheet.css"/>
</head>

<body data-spy="scroll" data-target=".idocs-navigation" data-offset="125">

<!-- Preloader -->
<div class="preloader">
    <div class="lds-ellipsis">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>
</div>
<!-- Preloader End -->

<!-- Document Wrapper   
=============================== -->
<div id="main-wrapper">

    <!-- Header
    ============================ -->
    <header id="header" class="sticky-top">
        <!-- Navbar -->
        <nav class="primary-menu navbar navbar-expand-lg navbar-dropdown-dark">
            <div class="container-fluid">
                <!-- Sidebar Toggler -->
                <button id="sidebarCollapse" class="navbar-toggler d-block d-md-none" type="button"><span></span><span
                        class="w-75"></span><span class="w-50"></span></button>

                <!-- Logo -->
                <a class="logo ml-md-3" href="index.html" title="iDocs Template"> <img
                        src="assets/images/primeCombinatorLogo.png" alt="iDocs Template" style="width: 40px "/> </a>
                <span style="margin-left:15px; font-size:30px">Prime combinator</span>
                <span class="text-2 ml-2">v1.0</span>
                <!-- Logo End -->

                <!-- Navbar Toggler -->
                <button class="navbar-toggler ml-auto" type="button" data-toggle="collapse" data-target="#header-nav">
                    <span></span><span></span><span></span></button>

                <div id="header-nav" class="collapse navbar-collapse justify-content-end">
                    <ul class="navbar-nav">

                        <li><a target="_blank" href="https://www.linkedin.com/in/roman-fantaev-427b65a2/">Linkedin
                            bio</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Navbar End -->
    </header>
    <!-- Header End -->

    <!-- Content
    ============================ -->
    <div id="content" role="main">

        <!-- Sidebar Navigation
        ============================ -->
        <div class="idocs-navigation bg-light">
            <ul class="nav flex-column ">
                <li class="nav-item"><a class="nav-link active" href="#idocs_start">Getting Started</a>
                    <ul class="nav flex-column">
                        <li class="nav-item"><a class="nav-link" href="#idocs_installation">Installation</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_html_structure">How to use</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_sass">How to create custom parser</a></li>
                    </ul>
                </li>
                <li class="nav-item"><a class="nav-link" href="#idocs_layout">Available parsers</a>
                    <ul class="nav flex-column">
                        <li class="nav-item"><a class="nav-link" href="#idocs_Any">Any</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_AnyCharacter">AnyCharacter</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_Beginning">Beginning</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_Between">Between</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_Character">Character</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_CustomWord">CustomWord</a></li>
			<li class=" nav-item"><a class="nav-link" href="#idocs_DoubleQuote">DoubleQuote</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_End">End</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_EndOfInputParser">EndOfInputParser</a>
                        </li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_EnglishDigit">EnglishDigit</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_EnglishLetter">EnglishLetter</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_Long">Long</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_Not">Not</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_Repeat">Repeat</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_RepeatableBetween">RepeatableBetween</a>
                        </li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_RepeatUntil">RepeatUntil</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_SequenceOf">SequenceOf</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_Spaces">Spaces</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_Str">Str</a></li>
                        <li class="nav-item"><a class="nav-link" href="#idocs_Word">Word</a></li>
                    </ul>
                </li>
                <li class="nav-item"><a class="nav-link" href="#idocs_faq">FAQ</a></li>
                <li class="nav-item"><a class="nav-link" href="#idocs_source_credits">Source & Credits</a></li>
                <li class="nav-item"><a class="nav-link" href="#idocs_changelog">Changelog</a>
                    <ul class="nav flex-column">
                        <li class="nav-item"><a class="nav-link" href="#v1-0">v1.0</a></li>
                    </ul>
                </li>
            </ul>
        </div>

        <!-- Docs Content
        ============================ -->
        <div class="idocs-content">
            <div class="container">

                <!-- Getting Started
                ============================ -->
                <section id="idocs_start">
                    <h1>Documentation</h1>
                    <h2>Prime combinator</h2>
                    <p>Parsing combinator with human-readable syntax</p>
                    <hr>
                    <div class="row">
                        <div class="col-sm-6 col-lg-4">
                            <ul class="list-unstyled">
                                <li><strong>Version:</strong> 1.0</li>
                                <li><strong>Author:</strong> <a
                                        href="https://www.linkedin.com/in/roman-fantaev-427b65a2/" target="_blank">Roman
                                    Fantaev</a></li>
                            </ul>
                        </div>
                        <div class="col-sm-6 col-lg-4">
                            <ul class="list-unstyled">
                                <li><strong class="font-weight-700">Created:</strong> 1 November, 2020</li>
                            </ul>
                        </div>
                    </div>
                    <p class="alert alert-info">If you have any questions that are beyond the scope of this help page,
                        Please feel free to <a href="mailto:FantaevRoman@gmail.com">email me</a></p>
                </section>

                <hr class="divider">

                <!-- Installation
                ============================ -->
                <section id="idocs_installation">
                    <h2>Installation</h2>
                    <p class="lead">Library is located at maven central:</p>

                    <h5>Maven:</h5>
                    <pre><code class="html">&lt;dependency&gt
     &lt;groupId>com.primeframeworks&lt;/groupId>
     &lt;artifactId>primeCombinator&lt;/artifactId>
     &lt;version>1.0.1&lt;/version>
     &lt;scope>compile&lt;/scope>
&lt;/dependency>
</code></pre>

                    <h5>Gradle:</h5>
                    <code class="html">
                        implementation com.primeframeworks:primeCombinator:1.0.1
                    </code>
                </section>

                <hr class="divider">

                <!-- HTML Structure
                ============================ -->
                <section id="idocs_html_structure">
                    <h2>How to use</h2>
                    <p>Let's say we need to fetch protocol and domain name from URL.
                        Here is an example how we take it from this address: <a
                                href="http://combinator.primeframeworks.com">http://combinator.primeframeworks.com</a>
                    </p>
                    <pre><code class="language-kotlin hljs">//Kotlin example

val parsedUrl = SequenceOf(
    Any(Str("http"), Str("https")),
    Str("://"),
    CustomWord(EnglishLetter().asChar(), Character('.')))
    .parse("http://combinator.primeframeworks.com")
    .get()

val protocol = (Any().fromSequence(parsedUrl.sequence, 0).anyOne as Str.StrParsed).str
val domainName = CustomWord().fromSequence(parsedUrl.sequence, 2).customWord

assertEquals("http", protocol)
assertEquals("combinator.primeframeworks.com", domainName)
</code></pre>
                    <p>In given example we specify that first in text there will either String: <code>"http"</code> or
                        String: <code>"https"</code>.
                        Next goes String:<code>"://"</code>.
                        Then goes word that consists of letters and symbol <code>"."</code> which forms full domain
                        name.</p>
                    <p>Because we parse <code>"sequence"</code> we have a list of results as an output where we know
                        that first element is<code>"Any"</code> and third is <code>"CustomWord"</code>.
                        We use <code>"fromSequence"</code> to convert parsed part into corresponding class and take
                        value.
                        We have to cast <code>Any().fromSequence(parsedUrl.sequence, 0)</code> to
                        <code>Str.StrParsed</code> because Any return "general type" (could be any) but we know that
                        only
                        <code>Str.StrParsed</code> could be returned as that is what <code>Str</code> parser produces.
                    </p>

                    <hr class="divider">

                    <!-- Sass
                    ============================ -->
                    <section id="idocs_sass">
                        <h2>How to create custom parser</h2>
                        <p>It is possible to create custom parser and combine with others. That is where <a
                                href="http://combinator.primeframeworks.com">primeCombinator</a> shines and gives you
                            ability to create very advance parsing logic with is easy to read.</p>
                    </section>
                    <pre><code class="language-kotlin hljs">//Kotlin example

class UrlParsed(val protocol: String, val domain: String, mappedFrom: Parsed) : Parsed(mappedFrom)

val urlParser = SequenceOf(
    Any(Str("http"), Str("https")),
    Str("://"),
    CustomWord(EnglishLetter().asChar(), Character('.'))
).map { sequenceParserOutput->
    val protocol = (Any().fromSequence(sequenceParserOutput.sequence, 0).anyOne as Str.StrParsed).str
    val domainName = CustomWord().fromSequence(sequenceParserOutput.sequence, 2).customWord

    UrlParsed(protocol, domainName, sequenceParserOutput)
}

val urlParsed = urlParser.parse("http://combinator.primeframeworks.com").get()

assertEquals("http", urlParsed.protocol)
assertEquals("combinator.primeframeworks.com", urlParsed.domain)</code></pre>
                    <p>Congratulations! Now you have custom parser <code>"urlParser"</code> and can combine it with
                        other Parsers.
                        You can try out:
                    </p>
                    <code class="language-kotlin hljs m-t-5">SequenceOf(Str("url: "),
                        urlParser).parse("url: http://combinator.primeframeworks.com")</code>
                    <br>

                    <p>
                        <code class="m-t-5">Parsed</code> is a general interface for parsers output. We created custom output <code>UrlParsed</code>
                        for custom parser <code>urlParser</code> and made it
                        strictly typed.
                    </p>

                    <code class="language-kotlin hljs">class UrlParsed(val protocol: String, val domain: String, mappedFrom: Parsed) : Parsed(mappedFrom)</code>
                    <br>
<p> This part with base constructor
    is needed to save positions in text from which
    parser reads. As we're only changing output but not parsing logic we simply copy indexes from
    output from "mapped" parser.
    In other words we save position "a" (where we started parse) and position "b" (where we stopped
    parsing) in <code>Parsed</code> core class.
    You always can simply use this approach for any custom parser without need to "look inside"
    framework unless you want to.</p>

                    <hr class="divider">


                    <!-- Layout
                    ============================ -->
                    <section id="idocs_layout">
                        <h2>Available parsers</h2>
                        <p class="lead">Documentation and examples of available parsers out of the box.</p>
                        <p class="lead">Parsers are compatible with each other.</p>

                    </section>
                    <hr class="divider">

                    <section id="idocs_Any">
                        <h2>Any</h2>
                        <p>Allows to specify several parsers and first successful is peeked as a result.
                            Parsers are tried in same order they specified in constructor.</p>
                        <pre><code class="language-kotlin hljs">//Kotlin example

val anyParsed = Any(Word(), EnglishDigit()).parse("1 is not a name").get()
assertEquals(0, anyParsed.indexStart)
assertEquals(0, anyParsed.indexEnd)
assertEquals(1, (anyParsed.anyOne as EnglishDigit.EnglishDigitParsed).digit)
</code></pre>
                        <p>Here parser tried to find word first, but words consists only from letters, so it fails, then
                            it tries <code>EnglishDigit</code>
                            which is successfully parsed first part of the string.
                        </p>
                        <p>Any parser returns <code>AnyParsed</code> which contains <code>anyOne</code> which is first
                            successful parser result (in our case it's <code>EnglishDigitParsed</code>).
                        </p>
                    </section>

                    <hr class="divider">

                    <section id="idocs_AnyCharacter">
                        <h2>AnyCharacter</h2>
                        <p>Takes any single character. Could be digit letter or symbol. Fails only if end of input</p>
                        <pre><code class="language-kotlin hljs">//Kotlin example

val anyCharacterParsed = AnyCharacter().parse("abc").get()
assertEquals(0, anyCharacterParsed.indexStart)
assertEquals(0, anyCharacterParsed.indexEnd)
assertEquals('a', anyCharacterParsed.char)>
</code></pre>
                        <p> We parsed first character in string. Result is <code>AnyCharacterParsed</code>.
                        </p>

                    </section>

                    <hr class="divider">

                    <section id="idocs_Beginning">
                        <h2>Beginning</h2>
                        <p>Parses beginning of input</p>
                        <pre><code class="language-kotlin hljs">//Kotlin example

val beginningParsing = Beginning().parse("").get()
assertEquals(0, beginningParsing.indexStart)
assertEquals(-1, beginningParsing.indexEnd)
</code></pre>
                        <p>Parsed beginning of empty string an got <code>BeginningParsed</code> without errors.</p>
                        <p><code>Beginning</code> is useful when we want parse whole document like:</p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val document =  SequenceOf(Beginning(), Repeat(Any(Word(), Spaces(), EnglishDigit())), End()).parse("1 is not a name").get()
val repeatParserOutput = document.sequence[1] as Repeat<Any.AnyParsed>.RepeatParsed
val eightParserResultInsideRepeat = repeatParserOutput.repeatersParsed[8].anyOne as Word.WordParsed
assertEquals("name", eightParserResultInsideRepeat.word)
</code></pre>
                    </section>
                    <hr class="divider">

                    <section id="idocs_Between">
                        <h2>Between</h2>
                        <p>Parses value included between something. Usually used with bracket for text like: <code>[value]</code></p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val betweenParsed = Between(Character('['), Character('b'), Character(']')).parse("[b]").get()
assertEquals(0, betweenParsed.indexStart)
assertEquals(2, betweenParsed.indexEnd)
assertEquals('b', betweenParsed.between.char)
assertEquals('[', betweenParsed.left.char)
assertEquals(']', betweenParsed.right.char)
</code></pre>
                        <p>Here we parsed character <code>"b"</code> included into brackets. Parser returns <code>BetweenParsed</code></p>

                    </section>
                    <hr class="divider">

                    <section id="idocs_Character">
                        <h2>Character</h2>
                        <p>Parses specified single character.</p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val characterParsed = Character('a').parse("abc").get()
assertEquals(0, characterParsed.indexStart)
assertEquals(0, characterParsed.indexEnd)
assertEquals('a', characterParsed.char)
</code></pre>
                        <p>Here we parsed specified character <code>"a"</code>. Parser returns <code>CharacterParsed</code></p>

                    </section>

                    <hr class="divider">


                    <section id="idocs_CustomWord">
                        <h2>CustomWord</h2>
                        <p>Parses word which consists of specified characters.
                            Normal <code>Word</code> parser takes only letters,<code>CustomWord</code> allows to specify any characters. Can be used to parse variable names, domains and other.  </p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val document =  CustomWord(EnglishLetter().asChar(), Character('.')).parse("my.domain.com").get()
assertEquals("my.domain.com", document.customWord)
</code></pre>
                        <p>Here we parsed domain name as a single custom word. Parser returns <code>CustomWordParsed</code></p>

                    </section>

                    <hr class="divider">


                    <section id="idocs_DoubleQuote">
                        <h2>DoubleQuote</h2>
                        <p>Allows to parse symbol <code>"</code> </p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val doubleQuoteParsed = DoubleQuote().parse(""""""").get()
assertEquals(0, doubleQuoteParsed.indexStart)
assertEquals(0, doubleQuoteParsed.indexEnd)
assertEquals(""""""", doubleQuoteParsed.str)
</code></pre>
                        <p>Here we parsed single <code>"</code>. Parser returns <code>Str</code></p>

                    </section>
                    <hr class="divider">

                    <section id="idocs_End">
                        <h2>End</h2>
                        <p>Parses end of the document</p>
                        <p><code>End</code> is useful when we want parse whole document like:</p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val document =  SequenceOf(Beginning(), Repeat(Any(Word(), Spaces(), EnglishDigit())), End()).parse("1 is not a name").get()
val repeatParserOutput = document.sequence[1] as Repeat<Any.AnyParsed>.RepeatParsed
val eightParserResultInsideRepeat = repeatParserOutput.repeatersParsed[8].anyOne as Word.WordParsed
assertEquals("name", eightParserResultInsideRepeat.word)
</code></pre>


                    </section>
                    <hr class="divider">


                    <section id="idocs_EndOfInputParser">
                        <h2>EndOfInputParser</h2>
                        <p>Abstruct class supposed to check if there is no end of input</p>
                        <pre><code class="language-kotlin hljs">//Kotlin
abstract class EndOfInputParser<T : Parsed> : Parser<T> {
    override fun parse(previous: Parsed): ParsedResult<T> {
        return if (previous.currentIndex() > previous.textMaxIndex()) {
            ParsedResult.asError("Unexpected end of input")
        } else {
            parseNext(previous)
        }
    }

    abstract fun parseNext(previous: Parsed): ParsedResult<T>
}
</code></pre>
                        <p>Usually inherited by Parses which need to parse 1 or more symbols</p>

                    </section>
                    <hr class="divider">


                    <section id="idocs_EnglishDigit">
                        <h2>EnglishDigit</h2>
                        <p>Allows to parse single digit <code>from 1 to 9</code> </p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val englishDigitParsed = EnglishDigit().parse("123").get()
assertEquals(0, englishDigitParsed.indexStart)
assertEquals(0, englishDigitParsed.indexEnd)
assertEquals(1, englishDigitParsed.digit)
</code></pre>
                        <p>Here we parsed single <code>1</code> digit. Parser returns <code>EnglishDigitParsed</code></p>

                    </section>
                    <hr class="divider">


                    <section id="idocs_EnglishLetter">
                        <h2>EnglishLetter</h2>
                        <p>Allows to parse one letter <code>a-z</code> or <code><code>A-Z</code></code> </p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val englishLetterParsed = EnglishLetter().parse("abv").get()
assertEquals(0, englishLetterParsed.indexStart)
assertEquals(0, englishLetterParsed.indexEnd)
assertEquals('a', englishLetterParsed.letter)
</code></pre>
                        <p>Here we parsed single letter <code>a</code>. Parser returns <code>EnglishLetterParsed</code></p>

                    </section>
                    <hr class="divider">



                    <section id="idocs_Long">
                        <h2>Long</h2>
                        <p>Allows to parse Long like<code>232312324</code> </p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val longParsed = Long().parse("134").get()
assertEquals(0, longParsed.indexStart)
assertEquals(2, longParsed.indexEnd)
assertEquals(134L, longParsed.long)
</code></pre>
                        <p>Here we parsed long: <code>134</code>. Parser returns <code>LongParsed</code></p>

                    </section>
                    <hr class="divider">


                    <section id="idocs_Not">
                        <h2>Not</h2>
                        <p>Not inverses parser. It doesn't capture end index! Meaning next parser will start from the same index</p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val notA = Not(Str("a")).parse("b").get()
assertEquals(0, notA.indexStart)
</code></pre>
                        <p>Here we parsed not symbol  <code>a</code>. Parser returns <code>NotParsed</code></p>

                    </section>
                    <hr class="divider">



                    <section id="idocs_Repeat">
                        <h2>Repeat</h2>
                        <p>Repeat specified parsers until fails </p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val repeatParsed = Repeat(EnglishLetter()).parse("Name1").get()
assertEquals(0, repeatParsed.indexStart)
assertEquals(3, repeatParsed.indexEnd)
assertEquals(4, repeatParsed.repeatersParsed.size)
</code></pre>
                        <p>Here we parsed <code>N,a,m,e</code> 4 letters. Parser returns <code>RepeatParsed</code></p>
                        <p>Note that digit is not parsed in the example</p>

                    </section>
                    <hr class="divider">


                    <section id="idocs_RepeatableBetween">
                        <h2>RepeatableBetween</h2>
                        <p>Allows to parse and join content between <code>"</code> </p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val repeatableBetweenParsed = RepeatableBetween(Str("["), EnglishLetter(), Str("]")).parse("[Na]").get()
assertEquals(0, repeatableBetweenParsed.indexStart)
assertEquals(3, repeatableBetweenParsed.indexEnd)
assertEquals("[", repeatableBetweenParsed.left.str)
assertEquals("]", repeatableBetweenParsed.right.str)
assertEquals(2, repeatableBetweenParsed.between.size)
assertEquals('N', repeatableBetweenParsed.between[0].letter)
assertEquals('a', repeatableBetweenParsed.between[1].letter)
</code></pre>
                        <p>Here we parsed 2 letters <code>N,a</code> between <code>[</code> and <code>]</code>. Parser returns <code>Str</code></p>
                        <p>Note that class has <code>joinRepeaters</code> which allows merging result</p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val repeatableBetweenParsed = RepeatableBetween(Str("["), EnglishLetter(), Str("]"))
    .joinRepeaters { it.map { it.letter }.joinToString(separator = "") }
    .parse("[Na]").get()
assertEquals(0, repeatableBetweenParsed.indexStart)
assertEquals(3, repeatableBetweenParsed.indexEnd)
assertEquals("Na", repeatableBetweenParsed.between)
</code></pre>
                    </section>
                    <hr class="divider">

                    <section id="idocs_RepeatUntil">
                        <h2>RepeatUntil</h2>
                        <p>Repeat until meets "until" </p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val repeatUntilParsed = RepeatUntil(Character('a'), Character('b')).parse("aaab").get()
assertEquals('a', repeatUntilParsed.repeatersParsed[0].char)
assertEquals('a', repeatUntilParsed.repeatersParsed[1].char)
assertEquals('a', repeatUntilParsed.repeatersParsed[2].char)
</code></pre>
                        <p>Here we parsed 3 times<code>a</code> before reached <code>b</code>. Parser returns <code>RepeatUntilParsed</code></p>

                    </section>
                    <hr class="divider">


                    <section id="idocs_SequenceOf">
                        <h2>SequenceOf</h2>
                        <p>SequenceOf parses sequence of parsers. Fails if at least one of parsers failed. Returns list with result of each parser in the same order as parsers supplied.</p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val parsedSequenceOf = SequenceOf(Beginning(), Spaces(), Word(), Spaces(), Word(), End()).parse("   Name is").get()

val beginning = Beginning().fromSequence(parsedSequenceOf.sequence, 0)
val spaces = Spaces().fromSequence(parsedSequenceOf.sequence, 1)
val name = Word().fromSequence(parsedSequenceOf.sequence, 2)
val spaces2 = Spaces().fromSequence(parsedSequenceOf.sequence, 3)
val wordIs = Word().fromSequence(parsedSequenceOf.sequence, 4)
val end = End().fromSequence(parsedSequenceOf.sequence, 5)

assertEquals("   ", spaces.spaces)
assertEquals("Name", name.word)
assertEquals("is", wordIs.word)
</code></pre>
                        <p>Here we parsed supplied set of parsers</p>
                        <p>Note that we can simply cast element from result list to desired class as an alternative approach(Make sure it corresponds to what type supplied parser is returning)</p>

                        <pre><code class="language-kotlin hljs">//Kotlin example
val document =  SequenceOf(Beginning(), Repeat(Any(Word(), Spaces(), EnglishDigit())), End()).parse("1 is not a name").get()
val repeatParserOutput = document.sequence[1] as Repeat.RepeatParsed
</code></pre>

                    </section>
                    <hr class="divider">


                    <section id="idocs_Spaces">
                        <h2>Spaces</h2>
                        <p>Parse single or several spaces at once</p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val parsedSpaces = Spaces().parse("   Name is ...").get()
assertEquals(parsedSpaces.spaces, "   ")
assertEquals(parsedSpaces.indexStart, 0)
assertEquals(parsedSpaces.indexEnd, 2)
</code></pre>
                        <p>Here we parsed 3 spaces <code>   </code>. Parser returns <code>SpacesParsed</code></p>

                    </section>
                    <hr class="divider">


                    <section id="idocs_Str">
                        <h2>Str</h2>
                        <p>Parse specified string </p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val strParsed = Str("One,").parse("One, two, here we go ").get()
assertEquals("One,", strParsed.str)
</code></pre>
                        <p>Here we parsed specified string<code>"One,"</code>. Parser returns <code>StrParsed</code></p>
                    </section>
                    <hr class="divider">



                    <section id="idocs_Word">
                        <h2>Word</h2>
                        <p>Parse any word which cosists only from english letters(see also #EnglishLetter)</p>
                        <pre><code class="language-kotlin hljs">//Kotlin example
val parsedWord = Word().parse("Name is ...").get()
assertEquals(parsedWord.word, "Name")
assertEquals(parsedWord.indexStart, 0)
assertEquals(parsedWord.indexEnd, 3)
</code></pre>
                        <p>Here we parsed first woed<code>Name</code> 4 letters. Parser returns <code>WordParsed</code></p>
                    </section>
                    <hr class="divider">


                    <!-- FAQ
                    ============================ -->
                    <section id="idocs_faq">
                        <h2>FAQ</h2>
                        <p class="text-4">A FAQ is a list of frequently asked questions (FAQs) and answers on a
                            particular topic.</p>

                        <div class="row">
                            <div class="col-lg-12">
                                <div class="accordion accordion-alterate arrow-right" id="popularTopics">
                                    <div class="card">
                                        <div class="card-header" id="heading1">
                                            <h5 class="mb-0"><a href="#" class="collapsed" data-toggle="collapse"
                                                                data-target="#collapse1" aria-expanded="false"
                                                                aria-controls="collapse1">Can i use framework in commercial project?</a></h5>
                                        </div>
                                        <div id="collapse1" class="collapse" aria-labelledby="heading1"
                                             data-parent="#popularTopics">
                                            <div class="card-body"> Yes, as long as you don't change author in classes from current framework.
                                                In other words you preserve author's name in files.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                    </section>

                    <hr class="divider">

                    <!-- Source & Credits
                    ============================ -->
                    <section id="idocs_source_credits">
                        <h2>Source & Credits</h2>
                        <h4>Html template:</h4>
                        <ul>
                            <li>HarnishDesign - <a target="_blank" href="https://themeforest.net/user/harnishdesign#contact">https://themeforest.net/user/harnishdesign#contact</a>
                            </li>
                        </ul>
                        <h4>Logo:</h4>
                        <ul>
                            <li>
                                <div>Icon made by <a href="https://www.freepik.com" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a></div>
                            </li>
                        </ul>
                    </section>

                    <hr class="divider">


                    <!-- Changelog
                    ============================ -->

                    <section id="idocs_changelog">
                        <h2>Changelog</h2>
                        <p class="text-4">See what's new added, changed, fixed, improved or updated in the latest
                            versions. </p>
                        <p class="alert alert-info mb-5"> For Future Updates Follow us on <a target="_blank"
                                                                                          href="https://github.com/fantaevroman/primeCombinator">git</a></p>

                        <h3 id="v1-0">Version 1.0 <small class="text-muted">1 November, 2020</small></h3>
                        <ul class="changelog">
                            <li><span class="badge badge-success">Added</span> Framework with basic Parsers
                            </li>
                        </ul>

                    </section>

            </div>
        </div>

    </div>
    <!-- Content end -->



</div>
<!-- Document Wrapper end -->

<!-- Back To Top -->
<a id="back-to-top" data-toggle="tooltip" title="Back to Top" href="javascript:void(0)"><i class="fa fa-chevron-up"></i></a>

<!-- JavaScript
============================ -->
<script src="assets/vendor/jquery/jquery.min.js"></script>
<script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
<!-- Highlight JS -->
<script src="assets/vendor/highlight.js/highlight.min.js"></script>
<!-- Easing -->
<script src="assets/vendor/jquery.easing/jquery.easing.min.js"></script>
<!-- Magnific Popup -->
<script src="assets/vendor/magnific-popup/jquery.magnific-popup.min.js"></script>
<!-- Custom Script -->
<script src="assets/js/theme.js"></script>
</body>
</html>
